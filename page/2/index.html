<!doctype html>
<!--[if lt IE 7 ]><html class="ie ie9below ie6"><![endif]-->
<!--[if IE 7 ]><html class="ie ie9below ie7"><![endif]-->
<!--[if IE 8 ]><html class="ie ie9below ie8"><![endif]-->
<!--[if IE 9 ]><html class="ie ie9"><![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html> <!--<![endif]-->
<head>
    <title>Jeeker</title>
    <meta charset="UTF-8">
    <link rel="apple-touch-icon" href="http://jeeker.net/assets/images/apple-touch-icon.png"/>
    <link rel="shortcut icon" type="image/x-icon" href="http://jeeker.net/assets/images/favicon.ico" />
    <link rel="stylesheet" type="text/css" href="http://jeeker.net/assets/style.css?77882" />
    <link rel="alternate" type="application/atom+xml" href="http://jeeker.net/atom.xml" />
    <!-- <link rel='canonical' href="" /> -->
    <meta name="robots" content="index,follow" />
    <!-- <meta name="keywords" content="" /> -->
</head>
<body>

<div id="wrapper">
    <div id="gradient"></div><!-- #gradient -->
    <div id="header">
        <div id="menu">
            <ul>
                <li><a href="http://jeeker.net/"><span>Home</span></a></li>
                <li><a href="http://jeeker.net/projects/"><span>Projects</span></a></li>
                <li><a href="http://jeeker.net/tags/"><span>Tags</span></a></li>
                <li><a href="http://jeeker.net/archives/"><span>Archives</span></a></li>
                <li><a href="http://jeeker.net/atom.xml"><span>Feed</span></a></li>
                <li><a href="http://jeeker.net/about/"><span>About</span></a></li>
            </ul>
        </div>
    </div><!-- ＃header -->

<div id="main">
    <div id="tools-box">
        <ul>
            <li id="tool-search">
                <form action="http://google.com/search" method="get">
                    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
                    <input type="hidden" name="q" value="site:jeeker.net" />
                </form>
            </li>
        </ul>
    </div><!-- #tools-box -->

<div id="container">
    <div id="content" role="main">


<div id="post-20269" class="post post-list post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/alfred-2-workflow-chinese-dictionary/" title="Alfred 2 Workflow: 中文词典" rel="bookmark">Alfred 2 Workflow: 中文词典</a></h1>
        <p class="entry-date" title="2013-03-29 09:24:29">
            <span class="day">29</span>
            <span class="month">Mar</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　英文不咋地，还不要脸总爱浏览国外的网站，于是字典成了我最重要的工具之一，OS X的三指查词虽然很方便，可惜系统自带的Dictionary即使装了中文词典用着也总觉得不太爽，什么时态什么复数都直接被忽视，平时还是多用在线词典，有需求就要尝试去实现，研究了下<a href="http://www.alfredapp.com/">Alfred</a> V2无比强大的<a href="http://support.alfredapp.com/workflows">Workflow</a>，写了这个基于在线词典的中英互查工具。</p>

<p><i><img src="http://jeeker.qiniudn.com/uploads/2013-03-29-alfred-2-workflow-chinese-dictionary/screenshot.png" alt="Alfred 2 Chinese Dictionary" /></i></p>

<p><span class="btn-group btn-center"><a href="https://github.com/JinnLynn/alfred-workflows/raw/master/bin/chinese-dictionary.alfredworkflow" class="btn btn-large icon-download-alt">Download</a><a href="https://github.com/JinnLynn/alfred-workflows/tree/master/src/chinese-dictionary" class="btn btn-large icon-github">Source</a></span></p>

<p>　　安装什么的就不说了，使用很简单：</p>

<ul>
<li>关键词: <code>cd</code></li>
<li>ENTER 打开<a href="http://dict.qq.com">QQ词典</a>查词结果</li>
<li>CMD + ENTENT 拷贝单词到剪切板</li>
<li>CTRL + ENTER 打开<a href="http://iciba.com">爱词霸</a>查词结果</li>
<li>ALT + ENTER 发音，取决于系统安装的<a href="http://support.apple.com/kb/PH10841?viewlocale=zh_CN">Text to Speech</a>，建议使用Siri的Samantha，纯正美音</li>
</ul>

<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
        <a href="http://jeeker.net/category/developer/" title="View all posts in Developer" rel="category tag">Developer</a>
</li>
            <li class="entry-human-time-diff"> on Mar 29, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/alfred-2-workflow-chinese-dictionary/#comments" title="Comment on Alfred 2 Workflow: 中文词典">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-20269 -->
<div id="post-64180" class="post post-list post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/first-arduino-experiment-show-amount-of-weibo-friend-new-status/" title="第一个Arduino实验: 新浪微博关注好友状态更新数量" rel="bookmark">第一个Arduino实验: 新浪微博关注好友状态更新数量</a></h1>
        <p class="entry-date" title="2013-03-20 15:23:00">
            <span class="day">20</span>
            <span class="month">Mar</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　一直想玩一玩电子设备，一般的单片机需要浪费太多时间在电子基础知识的学习上，不适合我这类人。</p>

<p>　　最后发现了<a href="http://arduino.cc/">Arduino</a>这个开源的硬件平台，社区活跃，对电子相关知识要求已是最低，于是订购了一个Arduino UNO的兼容版，上手挺容易，很快就折腾出了这个简单的小实验，功能是间隔三十秒获取新浪微博上好友状态更新数量并在数码管上显示。</p>

<h4 id="1-arduino">1. Arduino实验板连接</h4>

<p>　　实验板的连接不做详述，参考极客工坊的<a href="http://www.geek-workshop.com/thread-2038-1-1.html">这篇文章</a>，保证数码管引脚<code>E  D  C  DP B  A  F  G</code>分别对应Arduino数字输出2~9即可，Pin13做为电源输出。</p>

<h4 id="2">2. 程序源代码</h4>

<p>　　代码是Python2.7的，因此Arduino需预先写入<a href="http://firmata.org/">StandardFirmata</a>，而Python则需安装<a href="https://github.com/tino/pyFirmata">pyFirmata</a>模块。</p>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
#! 强制默认编码为utf-8
import sys
reload(sys)
sys.setdefaultencoding('utf8')

import pyfirmata, urllib, json, time
from datetime import datetime

#! 微博的API调用需要OAuth2.0登陆授权
#! 这里不做授权过程，需使用开发者账号测试 参考：http://t.cn/zYDjFan
ACCESS_TOKEN = 'YOUR ACCESS TOKEN'

# Arduino硬件接口
ARDUINO_PORT        = 'YOUR ARDUINO PORT'

POWER_PIN           = 13
DOTPOINT_PIN        = 5

NUMBERS = [
    #E  D  C  DP B  A  F  G   // 数码管
    #2  3  4  5  6  7  8  9   // 输出端口
    [0, 0, 0, 1, 0, 0, 0, 1], # 0
    [0, 1, 1, 1, 1, 1, 0, 1], # 1
    [0, 0, 1, 1, 0, 0, 1, 0], # 2 
    [1, 0, 0, 1, 0, 0, 1, 0], # 3
    [1, 1, 0, 1, 0, 1, 0, 0], # 4
    [1, 0, 0, 1, 1, 0, 0, 0], # 5
    [0, 0, 0, 1, 1, 0, 0, 0], # 6
    [1, 1, 0, 1, 0, 0, 1, 1], # 7
    [0, 0, 0, 1, 0, 0, 0, 0], # 8
    [1, 0, 0, 1, 0, 0, 0, 0], # 9
    [1, 1, 1, 0, 1, 1, 1, 1], # dot point
    [1, 1, 1, 1, 1, 1, 1, 0], # line
    [1, 1, 1, 1, 1, 1, 1, 1]  # nothing
]

class WBftc(object):
    def __init__(self):
        self.arduino = None
        self.lastStatusID = ''
        self.initArduino()

    def __del__(self):
        if isinstance(self.arduino, pyfirmata.Arduino):
            for i in xrange(2, 14):
                self.arduino.digital[i].write(0)

    def initArduino(self):
        if isinstance(self.arduino, pyfirmata.Arduino):
            return
        try:
            self.arduino = pyfirmata.Arduino(ARDUINO_PORT)
            self.arduino.digital[13].write(1)
        except Exception, e:
            print('init arduino fail.')
            sys.exit(1)

    def outputArduino(self, num):
        if not isinstance(self.arduino, pyfirmata.Arduino):
            return
        # 输出 0 - 9 的数字
        show = num
        # 小于0 错误
        if num &lt; 0:
            show = 12
        # 大于 9 超出量程
        elif num &gt; 9:
            show = 11
        for x in range(2, 10):
            self.arduino.digital[x].write(NUMBERS[show][x - 2])

    def flashDotPoint(self, interval = 1, count = 30):
        show_dot = True
        for x in range(count):
            self.arduino.digital[DOTPOINT_PIN].write(0 if show_dot else 1)
            show_dot = False if show_dot else True
            time.sleep(interval)

    def fetchWeiboStatusCount(self):
        # -1 错误
        url = 'https://api.weibo.com/2/statuses/friends_timeline/ids.json'
        data = {
            'access_token'  : ACCESS_TOKEN
        }
        if self.lastStatusID:
            data.update({'since_id' : self.lastStatusID })
        data = urllib.urlencode(data)
        try:
            requst = urllib.urlopen('{}?{}'.format(url, data))
            res = json.load(requst)
            if not res.has_key('statuses'):
                return -1
            statuses = res['statuses']
            if len(statuses):
                self.lastStatusID = statuses[0]
            return len(statuses)
        except Exception, e:
            print('something error.')
            return -1

    def run(self):
        while (True):
            count = self.fetchWeiboStatusCount()
            now = datetime.now().strftime('%H:%M:%S')
            print('{}: {}'.format(now, count))
            self.outputArduino(count)
            self.flashDotPoint()

if __name__ == '__main__':
    try:
        WBftc().run()
    except KeyboardInterrupt:
        print('\rexit.')
    except Exception, e:
        raise e
</code></pre>

<p><span class="btn-single btn-center"><a href="https://gist.github.com/JinnLynn/5210753" class="btn btn-large icon-github">Source on gist</a></span></p>

<p>　　需配置<code>ACCESS_TOKEN</code>和<code>ARDUINO_PORT</code>。</p>

<p>　　<strong>NOTE</strong>: 访问微博API需要OAuth2.0授权，这里使用了开发者测试账户，详细请参考<a href="http://t.cn/zYDjFan">这篇文章</a>。</p>

<h4 id="3">3. 显示结果</h4>

<p>　　程序每隔30秒获取关注好友更新的微博数量并以以下方式显示：</p>

<ul>
<li>更新数量在0-9间，数码管正常显示</li>
<li>更新数量大于9，数码管显示『-』</li>
<li>出错，数码管不显示任何内容</li>
<li>小数点闪动</li>
</ul>

<p>　　同时，电脑终端也会打印相应的更新数量信息，<code>CTRL+C</code>退出程序。</p>

<p><center>
    <iframe class="user-box" height="445" width="720" src="http://player.youku.com/embed/XNTI5NjQ0NDA4" frameborder="0" allowfullscreen></iframe>
</center></p>

<p><a href="http://jeeker.net/article/first-arduino-experiment-show-amount-of-weibo-friend-new-status/#more-64180" class="more-link">Read more...</a></p>
<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
</li>
            <li class="entry-human-time-diff"> on Mar 20, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/first-arduino-experiment-show-amount-of-weibo-friend-new-status/#comments" title="Comment on 第一个Arduino实验: 新浪微博关注好友状态更新数量">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-64180 -->
<div id="post-81780" class="post post-list post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/synology-nas-external-ip-change-notify/" title="Synology群晖NAS外部IP更新通知" rel="bookmark">Synology群晖NAS外部IP更新通知</a></h1>
        <p class="entry-date" title="2013-03-04 15:23:00">
            <span class="day">04</span>
            <span class="month">Mar</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　在我的群晖DS211j上使用DDNS服务时经常出现长时间无法正常更新IP的现象<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup>，这对于需要经常从外部访问的我来说是个很大的问题，于是写了段Python<sup class="footnote-ref" id="fnref-2"><a href="#fn-2">2</a></sup>脚本在NAS上监控外部IP地址的变化，如果发现改变将发送新的IP地址到指定的邮箱。<sup class="footnote-ref" id="fnref-3"><a href="#fn-3">3</a></sup></p>

<h3 id="1">1. 脚本</h3>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
#! 强制默认编码为utf-8
import sys
reload(sys)
sys.setdefaultencoding('utf8')

# 配置
# SMTP服务器 用户 密码
smtp_server = 'SMTP SERVER'
smtp_port   = 25
smtp_usr    = 'SMTP USERNAME'
smtp_pwd    = 'SMTP PASSWORD'

# 发送接受邮箱地址
#! 发送邮箱需是smtp_usr有权操作的邮箱
from_addr   = 'FROM EMAIL ADDRESS'
to_addr     = 'TO EMAIL ADDRESS'

# 获取外网IP的网址 可以是
# http://ifconfig.me/ip
# http://ip.3322.net
# http://members.3322.org/dyndns/getip
ip_check_server = 'http://ip.3322.net'

# 记录文件路径
log_file    = '/tmp/ipcheck.log'

# 邮件主题 
# 内容为新的IP
mail_subject = 'IP check message'

import os, urllib2, smtplib
from datetime import datetime

class CheckIP(object):
    def __init__(self):
        self.logs = []
        self.openLog()

    def __del__(self):
        self.saveLog()

    def openLog(self):
        if not os.path.isfile(log_file):
            open(log_file, 'w').close()
        with open(log_file, 'r') as f:
            self.logs = f.readlines()
        if not self.logs or len(self.logs) &lt; 2:
            self.logs = ['\n', '----\n']
        # 确保第二行永远是分隔符
        self.logs[1] = '----\n'

    def saveLog(self):
        with open(log_file, 'w') as f:
            f.writelines(self.logs)

    def getOldIP(self):
        return self.logs[0].strip()

    def setNewIP(self, new_ip):
        if new_ip:
            self.logs[0] = '{}\n'.format(new_ip)

    def sendMail(self, msg):
        if not msg:
            return
        data = {'from_addr' : from_addr,
                'to_addr'   : to_addr,
                'subject'   : mail_subject,
                'msg'       : msg }
        msg = 'From: {from_addr}\r\nTo: {to_addr}\r\nSubject: {subject}\r\n\r\n{msg}'.format(**data)
        try:
            smtp = smtplib.SMTP()
            # smtp.set_debuglevel(1)
            smtp.connect(smtp_server, smtp_port)
            smtp.login(smtp_usr, smtp_pwd)
            smtp.sendmail(from_addr, to_addr, msg)   
            smtp.quit()
        except Exception, e:
            return False, 'send mail fail. {}'.format(e)
        return True, None

    def log(self, msg, need_mail = False):
        if not msg:
            return
        print(msg)
        log_msg = '{}\t{}\n'.format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), msg)
        # 检查最近的记录，如果相同仅更新时间
        try:
            last_log = self.logs[2].split('\t')[1].strip()
            if last_log == msg:
                self.logs[2] = log_msg
            else:
                self.logs.insert(2, log_msg)
        except Exception, e:
            self.logs.insert(2, log_msg)

        if need_mail:
            self.sendMail(msg)

    def checkIP(self):
        old_ip = self.getOldIP()
        try:
            url = urllib2.Request(ip_check_server)
            res = urllib2.urlopen(url)
            new_ip = res.read().strip('\r\n ')
        except Exception, e:
            self.log('get ip fail. {}'.format(e), True)
            return
        if old_ip == new_ip:
            return self.log('IP unchanged.')
        res, msg = self.sendMail('IP Changed. {}'.format(new_ip))
        if not res:
            return self.log(msg)
        self.setNewIP(new_ip)
        self.log('IP changed. {}'.format(new_ip))

    def cleanLog(self):
        self.logs[2:] = []

    def run(self):
        if len(sys.argv) == 1:
            return self.checkIP()
        if '--clean' in sys.argv:
            return self.cleanLog()
        print('argument error.')

if __name__ == '__main__':
    ip = CheckIP()
    ip.run()
</code></pre>

<p><span class="btn-single btn-center"><a href="https://gist.github.com/JinnLynn/5080616" class="btn btn-large icon-github">Source on gist</a></span></p>

<ul>
<li>将上述代码另存为文本，并按脚本中的注释正确设置SMTP服务器、账户、密码、发送及接收邮箱地址</li>
<li>将文件上传至NAS，如<code>/root/ipcheck.py</code></li>
<li>使用<em>root</em>账户登陆NAS将该文件权限设置为可执行<code>chmod 744 /root/ipcheck.py</code></li>
<li>执行<code>/root/ipcheck.py</code>测试，正常情况下你设置的接收邮箱将会收到一个包含NAS当前IP地址的邮件，如果没有请检查前面的操作是否正确。</li>
</ul>

<h3 id="2">2. 设定定时任务</h3>

<p>　　用<em>root</em>账户执行<code>vi /etc/crontab</code><sup class="footnote-ref" id="fnref-4"><a href="#fn-4">4</a></sup>，在打开的文件末尾添加如下内容：</p>

<pre><code>*/10        *        *        *        *        root        /root/ipcheck.py
</code></pre>

<p>　　其中<code>*/10</code>意为每10分钟检查一次外部IP。</p>

<p>　　最后执行命令重启cron</p>

<pre><code>/usr/syno/etc.defaults/rc.d/S04crond.sh stop &amp;&amp; sleep 1 &amp;&amp; /usr/syno/etc.defaults/rc.d/S04crond.sh start
</code></pre>

<p>　　至此，NAS将每隔一段时间检查外部IP，一旦发现地址变化就会发送邮件通知。</p>

<h3 id="3">3. 其它</h3>

<ul>
<li><code>/tmp/ipcheck.txt</code>为默认保存当前ip地址信息及日志的文件，每次检查ip地址时都跟此文件内容比较，如果不同则发送通知邮件</li>
</ul>

<p><strong>REF</strong>:</p>

<p>　　<a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/">向StartSSL申请个人域名SSL证书</a></p>

<div class="footnotes">
<hr />
<ol>
<li id="fn-1">
<p>貌似这是群晖DDNS服务的通病，在DSM4.2已经允许设置多个DDNS服务，不过为以防万一，自行监控IP变化也不失为一个好的预防手段。&nbsp;<a href="#fnref-1" class="footnoteBackLink" title="Jump back to footnote 1 in the text.">&#8617;</a></p>
</li>

<li id="fn-2">
<p>群晖NAS DSM上默认不自带Python，需要从套件中心中安装。&nbsp;<a href="#fnref-2" class="footnoteBackLink" title="Jump back to footnote 2 in the text.">&#8617;</a></p>
</li>

<li id="fn-3">
<p>不仅仅只适用于群晖NAS，只要安装了Python的*nix系统均可正常使用。&nbsp;<a href="#fnref-3" class="footnoteBackLink" title="Jump back to footnote 3 in the text.">&#8617;</a></p>
</li>

<li id="fn-4">
<p>简单的vi操作: i进入编辑模式 esc 退出当前模式 : 进入命令行输入模式 w 保存内容 q 退出。&nbsp;<a href="#fnref-4" class="footnoteBackLink" title="Jump back to footnote 4 in the text.">&#8617;</a></p>
</li>
</ol>
</div>

<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
</li>
            <li class="entry-human-time-diff"> on Mar 04, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/synology-nas-external-ip-change-notify/#comments" title="Comment on Synology群晖NAS外部IP更新通知">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-81780 -->
<div id="post-73846" class="post post-list post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/" title="向StartSSL申请个人域名SSL证书" rel="bookmark">向StartSSL申请个人域名SSL证书</a></h1>
        <p class="entry-date" title="2013-01-21 21:10:46">
            <span class="day">21</span>
            <span class="month">Jan</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　为方便在外时访问，NAS使用了DDNS服务并绑定了jeeker.net的一个子域名，同时启用了<a href="http://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>连接以增强安全性，于是由于证书问题，每次访问NAS总出现烦人的警告。</p>

<p><i><img src="http://jeeker.qiniudn.com/uploads/2013-01-21-apply-ssl-certificat-for-domain-from-startssl/warn-page.png" alt="Chrome SSL Warning" /></i></p>

<p>　　解决这个问题的唯一方法当然就是安装一个有效的SSL证书，但向CA机构申请证书一年少者几十多者数千美元，很不划算，好在互联网上总不缺<a href="http://www.sslshopper.com/article-free-ssl-certificates-from-a-free-certificate-authority.html">免费午餐</a>，<a href="https://www.startssl.com/">StartSSL</a>就是很好的选择，下面就以它为例了解下SSL证书的申请和安装过程。</p>

<p><a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/#more-73846" class="more-link">Read more...</a></p>
<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
        <a href="http://jeeker.net/category/misc/" title="View all posts in Misc" rel="category tag">Misc</a>
</li>
            <li class="entry-human-time-diff"> on Jan 21, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/#comments" title="Comment on 向StartSSL申请个人域名SSL证书">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-73846 -->
<div id="post-42971" class="post post-list post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/remote-control-synology-download-station/" title="命令行远程控制Synology DSM Download Station" rel="bookmark">命令行远程控制Synology DSM Download Station</a></h1>
        <p class="entry-date" title="2013-01-16 21:29:31">
            <span class="day">16</span>
            <span class="month">Jan</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　入手<a href="http://www.synology.com/">Synology DS211j</a>近两年，所有下载工作都是通过其自带的Download Station来完成，毫无疑问，DS的功能已经足够强大，不过每次添加任务都要先登陆DSM，总让我觉得有点麻烦，一直想通过本地终端直接控制DS，但始终不得其法。</p>

<p>　　直到这两天才发现其实从DSM 3.2开始DS就已经提供了官方API，看了下<a href="http://download.synology.com/download/other/Synology_Download_Station_Official_API_V3.pdf">文档</a>，接口如同常见的网络轮询服务，也不复杂，于是写了一段Python脚本，支持在终端查看、添加、暂停、恢复、清理下载任务以及禁用或启用eMule，基本能够满足日常应用了。</p>

<p>　　代码结构很简单，如何使用直接看源代码吧，不多废话了。</p>

<pre><code>#! /usr/bin/env python
# -*- coding: utf-8 -*-

## 
# 使用Synology Download Station API远程控制文件下载
# http://download.synology.com/download/other/Synology_Download_Station_Official_API_V3.pdf
# Created by JinnLynn 2013.01.15 http://jeeker.net 
##

import json, urllib, urllib2, os, sys
from argparse import ArgumentParser
from pprint import pprint
reload(sys)
sys.setdefaultencoding('utf8')

# 设置: 网址 用户 密码
NAS_URL = ''
NAS_USR = ''
NAS_PWD = ''

CommonCodeDesc = {  100: 'Unknown error',
                    101: 'Invalid parameter',
                    102: 'The requested API does not exist',
                    103: 'The requested method does not exist',
                    104: 'The requested version does not support the functionality',
                    105: 'The logged in session does not have permission',
                    106: 'Session timeout',
                    107: 'Session interrupted by duplicate login'
                }

AuthCodeDesc = {    400: 'No such account or incorrect password',
                    401: 'Guest account disabled',
                    402: 'Account disabled',
                    403: 'Wrong password',
                    404: 'Permission denied'
                }

DSTaskCodeDesc = {  400: 'File upload failed',
                    401: 'Max number of tasks reached',
                    402: 'Destination denied',
                    403: 'Destination does not exist',
                    404: 'Invalid task id',
                    405: 'Invalid task action'
                }

DS_VERSION = '0.1'

class DownloadStation:
    def __init__(self):
        self.sessionID = ''
        self.tryLogin()
        self.debugInfo = {}
        self.lastError = ''

    def post(self, cgipath, data, subdir=''):
        if not isinstance(data, dict):
            print('data error')
            return
        if not data.has_key('version'):
            data.update({'version': 1})
        if not data.has_key('_sid'):
            data.update({'_sid': self.sessionID})
        data = urllib.urlencode(data)
        url = os.path.join(NAS_URL, 'webapi', subdir, cgipath)
        try:
            requst = urllib2.urlopen(url, data)
            res = json.load(requst)
        except:
            res = {'error': {'code': -1},'success': False}
        return res

    def login(self):
        data = { 'api':     'SYNO.API.Auth',
                 'method':  'login',
                 'version': 2,
                 'account': NAS_USR,
                 'passwd':  NAS_PWD,
                 'session': 'DownloadStation',
        }
        res = self.post('auth.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        self.sessionID = res['data']['sid']

    def logout(self):
        data = { 'api':     'SYNO.API.Auth',
                 'method':  'logout',
                 'session': 'DownloadStation'
        }
        res = self.post('auth.cgi', data)
        self.sessionID = ''

    def tryLogin(self):
        if self.sessionID == '':
            self.login()

    def test(self):
        self.tryLogin()
        data = { 'api':     'SYNO.DownloadStation.Info',
                 'method':  'getinfo'
        }
        res = self.post('DownloadStation/info.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        manager_info = ', and you are manager.' if res['data']['is_manager'] else '.'
        info = 'everything is ok, the version of Download Station is {}{}'.format(res['data']['version_string'], manager_info)
        print(info)


    # 显示当前下载速度
    def showStatistic(self):
        self.tryLogin()
        data = { 'api':     'SYNO.DownloadStation.Statistic',
                 'method':  'getinfo'
        }
        res = self.post('statistic.cgi', data, 'DownloadStation')
        if not self.isSuccess(res):
            self.die( self.lastError )
        speed_download          = self.humanSize(res['data']['speed_download'])
        speed_upload            = self.humanSize(res['data']['speed_upload'])
        info = '{:15} download {:10} upload {:10}'.format('Speed:', speed_download, speed_upload)
        print(info)
        if res['data'].has_key('emule_speed_download'):
            emule_speed_download    = self.humanSize(res['data']['emule_speed_download'])
            emule_speed_upload      = self.humanSize(res['data']['emule_speed_upload'])
            info = '{:15} download {:10} upload {:10}'.format('eMule Speed:', emule_speed_download, emule_speed_upload)
            print(info)
        else:
            print('eMule disabled.')

    # 显示当前任务信息
    def showTask(self, simple = False, include_seeding = False):
        self.tryLogin()
        if not simple:
            self.showStatistic()
        data = { 'api':         'SYNO.DownloadStation.Task',
                 'method':      'list',
                 'additional':  'transfer'
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        if not include_seeding:
            res['data']['tasks'] = filter(lambda t: t['status'] != 'seeding', res['data']['tasks'])
        if len(res['data']['tasks']) == 0:
            print('Task list is empty.')
            return
        title = '{:10}{:15}{:10}{:15}{:15}{}'.format('Type', 'Status', 'Size', 'Downloaded', 'Speed', 'Title')
        if simple:
            title = '{:40}{}'.format('Task ID', 'Title')
        print(title)

        for task in res['data']['tasks']:
            task['size'] = self.humanSize(task['size']);
            task['add_size_d'] = self.humanSize(task['additional']['transfer']['size_downloaded'])
            task['add_sued'] = self.humanSize(task['additional']['transfer']['size_uploaded'])
            task['add_speed_d'] = self.humanSize(task['additional']['transfer']['speed_download'])
            task['add_su'] = self.humanSize(task['additional']['transfer']['speed_upload'])
            info = '{type:10}{status:15}{size:10}{add_size_d:15}{add_speed_d:15}{title:30}'.format(**task)
            if simple:
                info = '{id:40}{title}'.format(**task)
            print(info)

    # 创建新的下载任务 参数可以是本地文件或链接
    def createTask(self, link_or_file):
        self.tryLogin()
        if not isinstance(link_or_file, (str, unicode, list)):
            self.die('arguments error')
        uris = ','.join(link_or_file) if isinstance(link_or_file, list) else link_or_file
        try:
            if os.path.isfile(uris):
                # 使用file参数似乎有问题 自己读
                with open(uris, 'r') as fp:
                    uris = ','.join(map(lambda s: s.strip('\n \t\r'), fp.readlines()))
        except:
            pass
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'create',
                 'uri':     uris
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        print('task created.')

    # 清理错误 及 已完成的任务
    #! eMule任务中 有seeding状态的无法删除
    def cleanTask(self):
        self.tryLogin()
        # 获取任务列表
        data = { 'api':         'SYNO.DownloadStation.Task',
                 'method':      'list',
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        need_clean = {}
        for task in res['data']['tasks']:
            # 错误 已完成 的清理
            if task['status'] == 'error' or task['status'] == 'finished':
                need_clean.update({task['id']: task['title']})
        if not len(need_clean):
            print('there is no task need to clean.')
            return
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'delete',
                 'id':      ','.join(need_clean.keys())
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        for task in res['data']:
            clean_res = 'clean success:' if task['error'] == 0 else 'clean fail(%d):' % task['error']
            title = need_clean[task['id']] if need_clean.has_key(task['id']) else task['id']
            info = '{:20}{}'.format(clean_res, title)
            print(info)

    def pauseTask(self, task_id = ''):
        self.tryLogin()
        # 未自定id则暂停所有
        if not task_id:
            # 获取任务列表
            data = { 'api':         'SYNO.DownloadStation.Task',
                     'method':      'list',
            }
            res = self.post('DownloadStation/task.cgi', data)
            if not self.isSuccess(res):
                self.die( self.lastError )
            ids = []
            for task in res['data']['tasks']:
                # eMule做种的任务无法暂停
                if not task['status'] == 'seeding':
                    ids.append(task['id'])
            if not len(ids):
                self.die('there is no task can be paused.')
            task_id = ',' . join(ids)

        data = { 'api': 'SYNO.DownloadStation.Task',
                 'method': 'pause',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        for task in res['data']:
            info = 'pause success:' if task['error'] == 0 else 'pause fail(%d):' % task['error']
            print( '{:20}{}'.format(info, task['id']) )

    def resumeTask(self, task_id = ''):
        self.tryLogin()
        # 未自定id则恢复所有
        if not task_id:
            # 获取任务列表
            data = { 'api':         'SYNO.DownloadStation.Task',
                     'method':      'list',
            }
            res = self.post('DownloadStation/task.cgi', data)
            if not self.isSuccess(res):
                self.die( self.lastError )
            ids = []
            for task in res['data']['tasks']:
                if task['status'] == 'paused':
                    ids.append(task['id'])
            if not len(ids):
                self.die('there is no task can be paused.')
            task_id = ',' . join(ids)
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'resume',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        for task in res['data']:
            info = 'resume success:' if task['error'] == 0 else 'resume fail(%d):' % task['error']
            print( '{:20}{}'.format(info, task['id']) )

    def deleteTask(self, task_id):
        self.tryLogin()
        # 获取待删除任务信息
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'getinfo',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        if not len(res['data']['tasks']):
            self.die('task is non-existent.')
        # 如果任务未完成 且 无错误 请求确认
        need_confirm = False
        for task in res['data']['tasks']:
            if task['status'] != 'error' and task['status'] != 'finished':
                need_confirm = True
                print( '{:20}{:40}{}'.format('task uncompleted:', task['id'], task['title']) )
        if need_confirm:
            if not raw_input('are you sure to delete it(yes/no)?:') == 'yes':
                return
        # 删除
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'delete',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        print('task deleted.')

    def eMule(self, is_enable):
        data = { 'api':             'SYNO.DownloadStation.Info',
                 'method':          'setserverconfig',
                 'emule_enabled':   'false' if not is_enable else 'true'
        }
        res = self.post('DownloadStation/info.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        print('eMule was %s' % ('enabled' if is_enable else 'disabled'))

    def isSuccess(self, res):
        if not isinstance(res, dict) or not res.has_key('success'):
            self.lastError = 'something error'
            return False
        if res['success']:
            self.lastError = ''
            return True
        self.lastError = 'Fail. error code: %d' % res['error']['code'] if res.has_key('error') and res['error'].has_key('code') else 'something error'
        return False

    def humanSize(self, byte):
        if isinstance(byte, (str, unicode)):
            byte = int(byte) if byte.isnumeric() else 0
        size = byte / 1024.0
        unit = 'KB'
        if size &gt; 1024:
            size = size / 1024.0
            unit = 'MB'
        if size &gt; 1024:
            size = size / 1024.0
            unit = 'GB'
        return '{:.2f}{}'.format(size, unit)

    def die(self, msg=''):
        if len(msg):
            sys.stderr.write(msg + '\n')
        sys.exit(1)

def main():
    parser = ArgumentParser(prog = 'ds', description = 'Synology NAS Download Station Tool.')
    parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + DS_VERSION)
    subparsers = parser.add_subparsers(title = 'subcommands', dest = 'sub_cmd')

    # 任务信息
    sub_info_parser = subparsers.add_parser('info', help = 'show task infomation')
    sub_info_parser.add_argument('--simple', action='store_true', default = False, help = 'only show task id and title')
    sub_info_parser.add_argument('--all', action='store_true', default = False, help = 'show all task')

    # 创建新任务
    sub_create_parser = subparsers.add_parser('create', help='create new task')
    sub_create_parser.add_argument('link_or_file', nargs = 1, help='single link or a file which include multi-links')

    # 清理任务
    sub_clean_parser = subparsers.add_parser('clean', help = 'clean error or completed task')

    # 暂停任务
    sub_pause_parser = subparsers.add_parser('pause', help = 'pause task')
    sub_pause_parser.add_argument('task_id', action='store', nargs='?', default = '')

    # 恢复任务
    sub_resume_parser = subparsers.add_parser('resume', help = 'resume task')
    sub_resume_parser.add_argument('task_id', nargs = '?', default = '')

    # 删除任务
    sub_delete_parser = subparsers.add_parser('delete', help = 'delete task')
    sub_delete_parser.add_argument('task_id')

    # eMule控制
    sub_emule_parser = subparsers.add_parser('emule', help = 'enable or disable eMule')
    sub_emule_parser.add_argument('operate', choices=['on', 'off'])

    # 测试
    sub_test_parser = subparsers.add_parser('test', help = 'test API')

    # 如果没有参数则默认输出info
    args = parser.parse_args(['info']) if len(sys.argv) == 1 else parser.parse_args()

    cmd_map = { 'info':     lambda: ds.showTask(args.simple, args.all),
                'create':   lambda: ds.createTask( args.link_or_file ),
                'clean':    lambda: ds.cleanTask(),
                'pause':    lambda: ds.pauseTask( args.task_id ),
                'resume':   lambda: ds.resumeTask( args.task_id ),
                'delete':   lambda: ds.deleteTask( args.task_id ),
                'emule':    lambda: ds.eMule( True if args.operate == 'on' else False),
                'test':     lambda: ds.test()
    }
    if cmd_map.has_key(args.sub_cmd):
        ds = DownloadStation()
        cmd_map[args.sub_cmd]()
        ds.logout()
    else:
        print('something error.')

if __name__ == '__main__':
    main()
</code></pre>

<p><span class="btn-single btn-center"><a href="https://github.com/JinnLynn/MacOSX-Kits/blob/master/Python/ds" class="btn btn-large icon-github">Source on GitHub</a></span></p>

<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
        <a href="http://jeeker.net/category/developer/" title="View all posts in Developer" rel="category tag">Developer</a>
</li>
            <li class="entry-human-time-diff"> on Jan 16, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/remote-control-synology-download-station/#comments" title="Comment on 命令行远程控制Synology DSM Download Station">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-42971 -->


    <div id="pagenavi">
        <span class="pages">Page 2 of 7</span>
        <a href="http://jeeker.net/page/3/" class="nav-older">Older</a>
        <a href="http://jeeker.net/" class="nav-newer">Newer</a>
    </div><!-- #pagenavi -->
   
    </div><!-- #content -->
</div><!-- #container -->

<div id="sidebar">
</div><!-- #sidebar -->

</div><!-- #main -->

<div id="footer">
    <div id="footer-left">
        2012 Powered By <a href="http://jeeker.net/projects/gude/" title="a simple python static website generator">Gude</a>. Code licensed under <a href="http://opensource.org/licenses/MIT">MIT License</a>,
        articles licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.
    </div><!-- #footer-left -->
    <div id="footer-right">
    </div><!-- #footer-right -->
</div><!-- #footer -->

</div><!-- #wrapper -->

<!-- print javascript -->
<script type="text/javascript" src="http://jeeker.net/assets/script/action.js?77882"></script>
<!--[if lt IE 9]>
<script type='text/javascript' src='http://jeeker.net/assets/script/css3-mediaqueries.js?77882'></script>
<![endif]-->

<script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey=1635756822" charset="utf-8"></script>
<script type="text/javascript" src="/assets/additional.js"></script>

<!-- google analytics track code -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-31118267-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

</body>
</html>