<!doctype html>
<!--[if lt IE 7 ]><html class="ie ie9below ie6"><![endif]-->
<!--[if IE 7 ]><html class="ie ie9below ie7"><![endif]-->
<!--[if IE 8 ]><html class="ie ie9below ie8"><![endif]-->
<!--[if IE 9 ]><html class="ie ie9"><![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html> <!--<![endif]-->
<head>
    <title>NAS - Jeeker</title>
    <meta charset="UTF-8">
    <link rel="apple-touch-icon" href="http://jeeker.net/assets/images/apple-touch-icon.png"/>
    <link rel="shortcut icon" type="image/x-icon" href="http://jeeker.net/assets/images/favicon.ico" />
    <link rel="stylesheet" type="text/css" href="http://jeeker.net/assets/style.css?99541" />
    <link rel="alternate" type="application/atom+xml" href="http://jeeker.net/atom.xml" />
    <!-- <link rel='canonical' href="" /> -->
    <meta name="robots" content="index,follow" />
    <!-- <meta name="keywords" content="" /> -->
</head>
<body>

<div id="wrapper">
    <div id="gradient"></div><!-- #gradient -->
    <div id="header">
        <div id="menu">
            <ul>
                <li><a href="http://jeeker.net/"><span>Home</span></a></li>
                <li><a href="http://jeeker.net/projects/"><span>Projects</span></a></li>
                <li><a href="http://jeeker.net/tags/"><span>Tags</span></a></li>
                <li><a href="http://jeeker.net/archives/"><span>Archives</span></a></li>
                <li><a href="http://jeeker.net/atom.xml"><span>Feed</span></a></li>
                <li><a href="http://jeeker.net/about/"><span>About</span></a></li>
            </ul>
        </div>
    </div><!-- ＃header -->

<div id="main">
    <div id="tools-box">
        <ul>
            <li id="tool-search">
                <form action="http://google.com/search" method="get">
                    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
                    <input type="hidden" name="q" value="site:jeeker.net" />
                </form>
            </li>
        </ul>
    </div><!-- #tools-box -->

<div id="container">
    <div id="content" role="main">



<div id="post-40669" class="post-list post post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/alfred-workflow-manage-synology-download-station/" title="Alfred Workflow: 管理Synology Download Station" rel="bookmark">Alfred Workflow: 管理Synology Download Station</a></h1>
        <p class="entry-date" title="2013-04-12 12:24:29">
            <span class="day">12</span>
            <span class="month">Apr</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　<a href="http://www.synology.com/dsm/home_home_applications_download_station.php?lang=chs">Download Station</a>是<a href="http://www.synology.com/dsm/index.php?lang=chs">Synology DSM</a>里我最喜欢的应用之一，我也曾写过一个<a href="http://jeeker.net/article/remote-control-synology-download-station/">在终端控制它的脚本</a>，Alfred的Workflow出现后我想到如果可能或许它是本地管理DS最方便的方式了，于是就有了这个，Download Station下载任务的创建、查看、暂停、恢复、删除等操作自然完全支持，也支持一些基本设置的管理如eMule、计划的启用与禁用等。</p>

<p><i><img src="http://static.afvisual.com/uploads/2013-04-12-alfred-workflow-manage-synology-download-station/screenshot-main.png" alt="DS Main" /></i></p>

<p>[btn url="https://github.com/JinnLynn/alfred-workflows/raw/master/bin/download-station.alfredworkflow,https://github.com/JinnLynn/alfred-workflows/tree/master/src/download-station" title="Download,Source" style="large" icon="download-alt,github"]</p>

<div class="footnotes">
<hr />
<ol>
</ol>
</div>

<p><a href="http://jeeker.net/article/alfred-workflow-manage-synology-download-station/#more-40669" class="more-link">Read more...</a></p>
<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
        <a href="http://jeeker.net/category/developer/" title="View all posts in Developer" rel="category tag">Developer</a>
</li>
            <li class="entry-human-time-diff"> on Apr 12, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/alfred-workflow-manage-synology-download-station/#comments" title="Comment on Alfred Workflow: 管理Synology Download Station">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-40669 -->
<div id="post-81780" class="post-list post post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/synology-nas-external-ip-change-notify/" title="Synology群晖NAS外部IP更新通知" rel="bookmark">Synology群晖NAS外部IP更新通知</a></h1>
        <p class="entry-date" title="2013-03-04 15:23:00">
            <span class="day">04</span>
            <span class="month">Mar</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　在我的群晖DS211j上使用DDNS服务时经常出现长时间无法正常更新IP的现象<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup>，这对于需要经常从外部访问的我来说是个很大的问题，于是写了段Python<sup class="footnote-ref" id="fnref-2"><a href="#fn-2">2</a></sup>脚本在NAS上监控外部IP地址的变化，如果发现改变将发送新的IP地址到指定的邮箱。<sup class="footnote-ref" id="fnref-3"><a href="#fn-3">3</a></sup></p>

<h3 id="1">1. 脚本</h3>

<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
#! 强制默认编码为utf-8
import sys
reload(sys)
sys.setdefaultencoding('utf8')

# 配置
# SMTP服务器 用户 密码
smtp_server = 'SMTP SERVER'
smtp_port   = 25
smtp_usr    = 'SMTP USERNAME'
smtp_pwd    = 'SMTP PASSWORD'

# 发送接受邮箱地址
#! 发送邮箱需是smtp_usr有权操作的邮箱
from_addr   = 'FROM EMAIL ADDRESS'
to_addr     = 'TO EMAIL ADDRESS'

# 获取外网IP的网址 可以是
# http://ifconfig.me/ip
# http://ip.3322.net
# http://members.3322.org/dyndns/getip
ip_check_server = 'http://ip.3322.net'

# 记录文件路径
log_file    = '/tmp/ipcheck.log'

# 邮件主题 
# 内容为新的IP
mail_subject = 'IP check message'

import os, urllib2, smtplib
from datetime import datetime

class CheckIP(object):
    def __init__(self):
        self.logs = []
        self.openLog()

    def __del__(self):
        self.saveLog()

    def openLog(self):
        if not os.path.isfile(log_file):
            open(log_file, 'w').close()
        with open(log_file, 'r') as f:
            self.logs = f.readlines()
        if not self.logs or len(self.logs) &lt; 2:
            self.logs = ['\n', '----\n']
        # 确保第二行永远是分隔符
        self.logs[1] = '----\n'

    def saveLog(self):
        with open(log_file, 'w') as f:
            f.writelines(self.logs)

    def getOldIP(self):
        return self.logs[0].strip()

    def setNewIP(self, new_ip):
        if new_ip:
            self.logs[0] = '{}\n'.format(new_ip)

    def sendMail(self, msg):
        if not msg:
            return
        data = {'from_addr' : from_addr,
                'to_addr'   : to_addr,
                'subject'   : mail_subject,
                'msg'       : msg }
        msg = 'From: {from_addr}\r\nTo: {to_addr}\r\nSubject: {subject}\r\n\r\n{msg}'.format(**data)
        try:
            smtp = smtplib.SMTP()
            # smtp.set_debuglevel(1)
            smtp.connect(smtp_server, smtp_port)
            smtp.login(smtp_usr, smtp_pwd)
            smtp.sendmail(from_addr, to_addr, msg)   
            smtp.quit()
        except Exception, e:
            return False, 'send mail fail. {}'.format(e)
        return True, None

    def log(self, msg, need_mail = False):
        if not msg:
            return
        print(msg)
        log_msg = '{}\t{}\n'.format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), msg)
        # 检查最近的记录，如果相同仅更新时间
        try:
            last_log = self.logs[2].split('\t')[1].strip()
            if last_log == msg:
                self.logs[2] = log_msg
            else:
                self.logs.insert(2, log_msg)
        except Exception, e:
            self.logs.insert(2, log_msg)

        if need_mail:
            self.sendMail(msg)

    def checkIP(self):
        old_ip = self.getOldIP()
        try:
            url = urllib2.Request(ip_check_server)
            res = urllib2.urlopen(url)
            new_ip = res.read().strip('\r\n ')
        except Exception, e:
            self.log('get ip fail. {}'.format(e), True)
            return
        if old_ip == new_ip:
            return self.log('IP unchanged.')
        res, msg = self.sendMail('IP Changed. {}'.format(new_ip))
        if not res:
            return self.log(msg)
        self.setNewIP(new_ip)
        self.log('IP changed. {}'.format(new_ip))

    def cleanLog(self):
        self.logs[2:] = []

    def run(self):
        if len(sys.argv) == 1:
            return self.checkIP()
        if '--clean' in sys.argv:
            return self.cleanLog()
        print('argument error.')

if __name__ == '__main__':
    ip = CheckIP()
    ip.run()
</code></pre>

<p>[btn url="https://gist.github.com/JinnLynn/5080616" title="Source on gist" style="large" icon="github"]</p>

<ul>
<li>将上述代码另存为文本，并按脚本中的注释正确设置SMTP服务器、账户、密码、发送及接收邮箱地址</li>
<li>将文件上传至NAS，如<code>/root/ipcheck.py</code></li>
<li>使用<em>root</em>账户登陆NAS将该文件权限设置为可执行<code>chmod 744 /root/ipcheck.py</code></li>
<li>执行<code>/root/ipcheck.py</code>测试，正常情况下你设置的接收邮箱将会收到一个包含NAS当前IP地址的邮件，如果没有请检查前面的操作是否正确。</li>
</ul>

<h3 id="2">2. 设定定时任务</h3>

<p>　　用<em>root</em>账户执行<code>vi /etc/crontab</code><sup class="footnote-ref" id="fnref-4"><a href="#fn-4">4</a></sup>，在打开的文件末尾添加如下内容：</p>

<pre><code>*/10        *        *        *        *        root        /root/ipcheck.py
</code></pre>

<p>　　其中<code>*/10</code>意为每10分钟检查一次外部IP。</p>

<p>　　最后执行命令重启cron</p>

<pre><code>/usr/syno/etc.defaults/rc.d/S04crond.sh stop &amp;&amp; sleep 1 &amp;&amp; /usr/syno/etc.defaults/rc.d/S04crond.sh start
</code></pre>

<p>　　至此，NAS将每隔一段时间检查外部IP，一旦发现地址变化就会发送邮件通知。</p>

<h3 id="3">3. 其它</h3>

<ul>
<li><code>/tmp/ipcheck.txt</code>为默认保存当前ip地址信息及日志的文件，每次检查ip地址时都跟此文件内容比较，如果不同则发送通知邮件</li>
</ul>

<p><strong>REF</strong>:</p>

<p>　　<a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/">向StartSSL申请个人域名SSL证书</a></p>

<div class="footnotes">
<hr />
<ol>
<li id="fn-1">
<p>貌似这是群晖DDNS服务的通病，在DSM4.2已经允许设置多个DDNS服务，不过为以防万一，自行监控IP变化也不失为一个好的预防手段。&nbsp;<a href="#fnref-1" class="footnoteBackLink" title="Jump back to footnote 1 in the text.">&#8617;</a></p>
</li>

<li id="fn-2">
<p>群晖NAS DSM上默认不自带Python，需要从套件中心中安装。&nbsp;<a href="#fnref-2" class="footnoteBackLink" title="Jump back to footnote 2 in the text.">&#8617;</a></p>
</li>

<li id="fn-3">
<p>不仅仅只适用于群晖NAS，只要安装了Python的*nix系统均可正常使用。&nbsp;<a href="#fnref-3" class="footnoteBackLink" title="Jump back to footnote 3 in the text.">&#8617;</a></p>
</li>

<li id="fn-4">
<p>简单的vi操作: i进入编辑模式 esc 退出当前模式 : 进入命令行输入模式 w 保存内容 q 退出。&nbsp;<a href="#fnref-4" class="footnoteBackLink" title="Jump back to footnote 4 in the text.">&#8617;</a></p>
</li>
</ol>
</div>

<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
</li>
            <li class="entry-human-time-diff"> on Mar 04, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/synology-nas-external-ip-change-notify/#comments" title="Comment on Synology群晖NAS外部IP更新通知">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-81780 -->
<div id="post-73846" class="post-list post post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/" title="向StartSSL申请个人域名SSL证书" rel="bookmark">向StartSSL申请个人域名SSL证书</a></h1>
        <p class="entry-date" title="2013-01-21 21:10:46">
            <span class="day">21</span>
            <span class="month">Jan</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　为方便在外时访问，NAS使用了DDNS服务并绑定了jeeker.net的一个子域名，同时启用了<a href="http://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>连接以增强安全性，于是由于证书问题，每次访问NAS总出现烦人的警告。</p>

<p><i><img src="http://static.afvisual.com/uploads/2013-01-21-apply-ssl-certificat-for-domain-from-startssl/warn-page.png" alt="Chrome SSL Warning" /></i></p>

<p>　　解决这个问题的唯一方法当然就是安装一个有效的SSL证书，但向CA机构申请证书一年少者几十多者数千美元，很不划算，好在互联网上总不缺<a href="http://www.sslshopper.com/article-free-ssl-certificates-from-a-free-certificate-authority.html">免费午餐</a>，<a href="https://www.startssl.com/">StartSSL</a>就是很好的选择，下面就以它为例了解下SSL证书的申请和安装过程。</p>

<p><a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/#more-73846" class="more-link">Read more...</a></p>
<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
        <a href="http://jeeker.net/category/misc/" title="View all posts in Misc" rel="category tag">Misc</a>
</li>
            <li class="entry-human-time-diff"> on Jan 21, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/apply-ssl-certificat-for-domain-from-startssl/#comments" title="Comment on 向StartSSL申请个人域名SSL证书">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-73846 -->
<div id="post-42971" class="post-list post post-post post-publish">
    <div class="entry-head">
        <h1><a href="http://jeeker.net/article/remote-control-synology-download-station/" title="命令行远程控制Synology DSM Download Station" rel="bookmark">命令行远程控制Synology DSM Download Station</a></h1>
        <p class="entry-date" title="2013-01-16 21:29:31">
            <span class="day">16</span>
            <span class="month">Jan</span>
        </p>
    </div><!-- .entry-header -->
    <div class="entry-content">
<!-- content start -->
<p>　　入手<a href="http://www.synology.com/">Synology DS211j</a>近两年，所有下载工作都是通过其自带的Download Station来完成，毫无疑问，DS的功能已经足够强大，不过每次添加任务都要先登陆DSM，总让我觉得有点麻烦，一直想通过本地终端直接控制DS，但始终不得其法。</p>

<p>　　直到这两天才发现其实从DSM 3.2开始DS就已经提供了官方API，看了下<a href="http://download.synology.com/download/other/Synology_Download_Station_Official_API_V3.pdf">文档</a>，接口如同常见的网络轮询服务，也不复杂，于是写了一段Python脚本，支持在终端查看、添加、暂停、恢复、清理下载任务以及禁用或启用eMule，基本能够满足日常应用了。</p>

<p>　　代码结构很简单，如何使用直接看源代码吧，不多废话了。</p>

<pre><code>#! /usr/bin/env python
# -*- coding: utf-8 -*-

## 
# 使用Synology Download Station API远程控制文件下载
# http://download.synology.com/download/other/Synology_Download_Station_Official_API_V3.pdf
# Created by JinnLynn 2013.01.15 http://jeeker.net 
##

import json, urllib, urllib2, os, sys
from argparse import ArgumentParser
from pprint import pprint
reload(sys)
sys.setdefaultencoding('utf8')

# 设置: 网址 用户 密码
NAS_URL = ''
NAS_USR = ''
NAS_PWD = ''

CommonCodeDesc = {  100: 'Unknown error',
                    101: 'Invalid parameter',
                    102: 'The requested API does not exist',
                    103: 'The requested method does not exist',
                    104: 'The requested version does not support the functionality',
                    105: 'The logged in session does not have permission',
                    106: 'Session timeout',
                    107: 'Session interrupted by duplicate login'
                }

AuthCodeDesc = {    400: 'No such account or incorrect password',
                    401: 'Guest account disabled',
                    402: 'Account disabled',
                    403: 'Wrong password',
                    404: 'Permission denied'
                }

DSTaskCodeDesc = {  400: 'File upload failed',
                    401: 'Max number of tasks reached',
                    402: 'Destination denied',
                    403: 'Destination does not exist',
                    404: 'Invalid task id',
                    405: 'Invalid task action'
                }

DS_VERSION = '0.1'

class DownloadStation:
    def __init__(self):
        self.sessionID = ''
        self.tryLogin()
        self.debugInfo = {}
        self.lastError = ''

    def post(self, cgipath, data, subdir=''):
        if not isinstance(data, dict):
            print('data error')
            return
        if not data.has_key('version'):
            data.update({'version': 1})
        if not data.has_key('_sid'):
            data.update({'_sid': self.sessionID})
        data = urllib.urlencode(data)
        url = os.path.join(NAS_URL, 'webapi', subdir, cgipath)
        try:
            requst = urllib2.urlopen(url, data)
            res = json.load(requst)
        except:
            res = {'error': {'code': -1},'success': False}
        return res

    def login(self):
        data = { 'api':     'SYNO.API.Auth',
                 'method':  'login',
                 'version': 2,
                 'account': NAS_USR,
                 'passwd':  NAS_PWD,
                 'session': 'DownloadStation',
        }
        res = self.post('auth.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        self.sessionID = res['data']['sid']

    def logout(self):
        data = { 'api':     'SYNO.API.Auth',
                 'method':  'logout',
                 'session': 'DownloadStation'
        }
        res = self.post('auth.cgi', data)
        self.sessionID = ''

    def tryLogin(self):
        if self.sessionID == '':
            self.login()

    def test(self):
        self.tryLogin()
        data = { 'api':     'SYNO.DownloadStation.Info',
                 'method':  'getinfo'
        }
        res = self.post('DownloadStation/info.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        manager_info = ', and you are manager.' if res['data']['is_manager'] else '.'
        info = 'everything is ok, the version of Download Station is {}{}'.format(res['data']['version_string'], manager_info)
        print(info)


    # 显示当前下载速度
    def showStatistic(self):
        self.tryLogin()
        data = { 'api':     'SYNO.DownloadStation.Statistic',
                 'method':  'getinfo'
        }
        res = self.post('statistic.cgi', data, 'DownloadStation')
        if not self.isSuccess(res):
            self.die( self.lastError )
        speed_download          = self.humanSize(res['data']['speed_download'])
        speed_upload            = self.humanSize(res['data']['speed_upload'])
        info = '{:15} download {:10} upload {:10}'.format('Speed:', speed_download, speed_upload)
        print(info)
        if res['data'].has_key('emule_speed_download'):
            emule_speed_download    = self.humanSize(res['data']['emule_speed_download'])
            emule_speed_upload      = self.humanSize(res['data']['emule_speed_upload'])
            info = '{:15} download {:10} upload {:10}'.format('eMule Speed:', emule_speed_download, emule_speed_upload)
            print(info)
        else:
            print('eMule disabled.')

    # 显示当前任务信息
    def showTask(self, simple = False, include_seeding = False):
        self.tryLogin()
        if not simple:
            self.showStatistic()
        data = { 'api':         'SYNO.DownloadStation.Task',
                 'method':      'list',
                 'additional':  'transfer'
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        if not include_seeding:
            res['data']['tasks'] = filter(lambda t: t['status'] != 'seeding', res['data']['tasks'])
        if len(res['data']['tasks']) == 0:
            print('Task list is empty.')
            return
        title = '{:10}{:15}{:10}{:15}{:15}{}'.format('Type', 'Status', 'Size', 'Downloaded', 'Speed', 'Title')
        if simple:
            title = '{:40}{}'.format('Task ID', 'Title')
        print(title)

        for task in res['data']['tasks']:
            task['size'] = self.humanSize(task['size']);
            task['add_size_d'] = self.humanSize(task['additional']['transfer']['size_downloaded'])
            task['add_sued'] = self.humanSize(task['additional']['transfer']['size_uploaded'])
            task['add_speed_d'] = self.humanSize(task['additional']['transfer']['speed_download'])
            task['add_su'] = self.humanSize(task['additional']['transfer']['speed_upload'])
            info = '{type:10}{status:15}{size:10}{add_size_d:15}{add_speed_d:15}{title:30}'.format(**task)
            if simple:
                info = '{id:40}{title}'.format(**task)
            print(info)

    # 创建新的下载任务 参数可以是本地文件或链接
    def createTask(self, link_or_file):
        self.tryLogin()
        if not isinstance(link_or_file, (str, unicode, list)):
            self.die('arguments error')
        uris = ','.join(link_or_file) if isinstance(link_or_file, list) else link_or_file
        try:
            if os.path.isfile(uris):
                # 使用file参数似乎有问题 自己读
                with open(uris, 'r') as fp:
                    uris = ','.join(map(lambda s: s.strip('\n \t\r'), fp.readlines()))
        except:
            pass
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'create',
                 'uri':     uris
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        print('task created.')

    # 清理错误 及 已完成的任务
    #! eMule任务中 有seeding状态的无法删除
    def cleanTask(self):
        self.tryLogin()
        # 获取任务列表
        data = { 'api':         'SYNO.DownloadStation.Task',
                 'method':      'list',
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        need_clean = {}
        for task in res['data']['tasks']:
            # 错误 已完成 的清理
            if task['status'] == 'error' or task['status'] == 'finished':
                need_clean.update({task['id']: task['title']})
        if not len(need_clean):
            print('there is no task need to clean.')
            return
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'delete',
                 'id':      ','.join(need_clean.keys())
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        for task in res['data']:
            clean_res = 'clean success:' if task['error'] == 0 else 'clean fail(%d):' % task['error']
            title = need_clean[task['id']] if need_clean.has_key(task['id']) else task['id']
            info = '{:20}{}'.format(clean_res, title)
            print(info)

    def pauseTask(self, task_id = ''):
        self.tryLogin()
        # 未自定id则暂停所有
        if not task_id:
            # 获取任务列表
            data = { 'api':         'SYNO.DownloadStation.Task',
                     'method':      'list',
            }
            res = self.post('DownloadStation/task.cgi', data)
            if not self.isSuccess(res):
                self.die( self.lastError )
            ids = []
            for task in res['data']['tasks']:
                # eMule做种的任务无法暂停
                if not task['status'] == 'seeding':
                    ids.append(task['id'])
            if not len(ids):
                self.die('there is no task can be paused.')
            task_id = ',' . join(ids)

        data = { 'api': 'SYNO.DownloadStation.Task',
                 'method': 'pause',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        for task in res['data']:
            info = 'pause success:' if task['error'] == 0 else 'pause fail(%d):' % task['error']
            print( '{:20}{}'.format(info, task['id']) )

    def resumeTask(self, task_id = ''):
        self.tryLogin()
        # 未自定id则恢复所有
        if not task_id:
            # 获取任务列表
            data = { 'api':         'SYNO.DownloadStation.Task',
                     'method':      'list',
            }
            res = self.post('DownloadStation/task.cgi', data)
            if not self.isSuccess(res):
                self.die( self.lastError )
            ids = []
            for task in res['data']['tasks']:
                if task['status'] == 'paused':
                    ids.append(task['id'])
            if not len(ids):
                self.die('there is no task can be paused.')
            task_id = ',' . join(ids)
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'resume',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        for task in res['data']:
            info = 'resume success:' if task['error'] == 0 else 'resume fail(%d):' % task['error']
            print( '{:20}{}'.format(info, task['id']) )

    def deleteTask(self, task_id):
        self.tryLogin()
        # 获取待删除任务信息
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'getinfo',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        if not len(res['data']['tasks']):
            self.die('task is non-existent.')
        # 如果任务未完成 且 无错误 请求确认
        need_confirm = False
        for task in res['data']['tasks']:
            if task['status'] != 'error' and task['status'] != 'finished':
                need_confirm = True
                print( '{:20}{:40}{}'.format('task uncompleted:', task['id'], task['title']) )
        if need_confirm:
            if not raw_input('are you sure to delete it(yes/no)?:') == 'yes':
                return
        # 删除
        data = { 'api':     'SYNO.DownloadStation.Task',
                 'method':  'delete',
                 'id':      task_id
        }
        res = self.post('DownloadStation/task.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        print('task deleted.')

    def eMule(self, is_enable):
        data = { 'api':             'SYNO.DownloadStation.Info',
                 'method':          'setserverconfig',
                 'emule_enabled':   'false' if not is_enable else 'true'
        }
        res = self.post('DownloadStation/info.cgi', data)
        if not self.isSuccess(res):
            self.die( self.lastError )
        print('eMule was %s' % ('enabled' if is_enable else 'disabled'))

    def isSuccess(self, res):
        if not isinstance(res, dict) or not res.has_key('success'):
            self.lastError = 'something error'
            return False
        if res['success']:
            self.lastError = ''
            return True
        self.lastError = 'Fail. error code: %d' % res['error']['code'] if res.has_key('error') and res['error'].has_key('code') else 'something error'
        return False

    def humanSize(self, byte):
        if isinstance(byte, (str, unicode)):
            byte = int(byte) if byte.isnumeric() else 0
        size = byte / 1024.0
        unit = 'KB'
        if size &gt; 1024:
            size = size / 1024.0
            unit = 'MB'
        if size &gt; 1024:
            size = size / 1024.0
            unit = 'GB'
        return '{:.2f}{}'.format(size, unit)

    def die(self, msg=''):
        if len(msg):
            sys.stderr.write(msg + '\n')
        sys.exit(1)

def main():
    parser = ArgumentParser(prog = 'ds', description = 'Synology NAS Download Station Tool.')
    parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + DS_VERSION)
    subparsers = parser.add_subparsers(title = 'subcommands', dest = 'sub_cmd')

    # 任务信息
    sub_info_parser = subparsers.add_parser('info', help = 'show task infomation')
    sub_info_parser.add_argument('--simple', action='store_true', default = False, help = 'only show task id and title')
    sub_info_parser.add_argument('--all', action='store_true', default = False, help = 'show all task')

    # 创建新任务
    sub_create_parser = subparsers.add_parser('create', help='create new task')
    sub_create_parser.add_argument('link_or_file', nargs = 1, help='single link or a file which include multi-links')

    # 清理任务
    sub_clean_parser = subparsers.add_parser('clean', help = 'clean error or completed task')

    # 暂停任务
    sub_pause_parser = subparsers.add_parser('pause', help = 'pause task')
    sub_pause_parser.add_argument('task_id', action='store', nargs='?', default = '')

    # 恢复任务
    sub_resume_parser = subparsers.add_parser('resume', help = 'resume task')
    sub_resume_parser.add_argument('task_id', nargs = '?', default = '')

    # 删除任务
    sub_delete_parser = subparsers.add_parser('delete', help = 'delete task')
    sub_delete_parser.add_argument('task_id')

    # eMule控制
    sub_emule_parser = subparsers.add_parser('emule', help = 'enable or disable eMule')
    sub_emule_parser.add_argument('operate', choices=['on', 'off'])

    # 测试
    sub_test_parser = subparsers.add_parser('test', help = 'test API')

    # 如果没有参数则默认输出info
    args = parser.parse_args(['info']) if len(sys.argv) == 1 else parser.parse_args()

    cmd_map = { 'info':     lambda: ds.showTask(args.simple, args.all),
                'create':   lambda: ds.createTask( args.link_or_file ),
                'clean':    lambda: ds.cleanTask(),
                'pause':    lambda: ds.pauseTask( args.task_id ),
                'resume':   lambda: ds.resumeTask( args.task_id ),
                'delete':   lambda: ds.deleteTask( args.task_id ),
                'emule':    lambda: ds.eMule( True if args.operate == 'on' else False),
                'test':     lambda: ds.test()
    }
    if cmd_map.has_key(args.sub_cmd):
        ds = DownloadStation()
        cmd_map[args.sub_cmd]()
        ds.logout()
    else:
        print('something error.')

if __name__ == '__main__':
    main()
</code></pre>

<p>[btn url="https://github.com/JinnLynn/MacOSX-Kits/blob/master/Python/ds" title="Source on GitHub" style="large" icon="github"]</p>

<!-- content end -->
    </div><!-- .entry-content -->
    <div class="entry-meta">
        <ul>
            <li class="entry-author">Posted by JinnLynn</li>
            <li class="entry-categories"> in 
        <a href="http://jeeker.net/category/developer/" title="View all posts in Developer" rel="category tag">Developer</a>
</li>
            <li class="entry-human-time-diff"> on Jan 16, 2013</li>
            <li class="entry-comments"> with <a href="http://jeeker.net/article/remote-control-synology-download-station/#comments" title="Comment on 命令行远程控制Synology DSM Download Station">Comments</a></li> 
        </ul>
    </div><!-- .entry-meta -->
</div><!-- #post-42971 -->


    <div id="pagenavi">
        <span class="pages">Page 1 of 1</span>
    </div><!-- #pagenavi -->
   
    </div><!-- #content -->
</div><!-- #container -->

<div id="sidebar">
</div><!-- #sidebar -->

</div><!-- #main -->

<div id="footer">
    <div id="footer-left">
        2012 Powered By <a href="http://jeeker.net/projects/gude/" title="a simple python static website generator">Gude</a>. Code licensed under <a href="http://opensource.org/licenses/MIT">MIT License</a>,
        articles licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.
    </div><!-- #footer-left -->
    <div id="footer-right">
    </div><!-- #footer-right -->
</div><!-- #footer -->

</div><!-- #wrapper -->

<!-- print javascript -->
<script type="text/javascript" src="http://jeeker.net/assets/script/action.js?42566"></script>
<!--[if lt IE 9]>
<script type='text/javascript' src='http://jeeker.net/assets/script/css3-mediaqueries.js?58572'></script>
<![endif]-->

<script type="text/javascript" src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey=1635756822" charset="utf-8"></script>
<script type="text/javascript" src="/assets/additional.js"></script>

<!-- google analytics track code -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-31118267-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

</body>
</html>